+++
title = "数字证书和数字签名那些事"
date = 2024-04-23
[taxonomies]
tags = ["杂文"]
+++

非对称加密, 数字证书和数字签名这些虽然是相对底层的概念, 但由于计算机的世界愈发复杂, 信任和安全也愈发重要, 他们扮演的角色也就愈发的重要, 在web通信, 区块链, 电子邮件, 电子签名, 智能家居等等数不胜数的场景中, 都可以发现这些技术的身影. 这篇文章将讲述数字证书, 数字签名这些概念，以及CA, OCSP等与之相关内容, 希望可以对想了解这方面内容的读者有所帮助.

<!-- more -->

## 公钥, 私钥和非对称密码

通常我们把加密前的原数据叫做原文, 加密后的内容叫做密文. 对称密码(比如DES, AES)指的是, 在加密和解密的过程中, 使用的是同一个密钥. 影视剧中, 经常有情报人员用某本书加上一组数字来传递消息这样的场景, 这就是一种对称加密的方式, 消息(原文)转换到数字(密文)是加密, 数字(密文)再转回消息(原文)是解密, 而"书"就充当了密钥.

{{ image(src="/image/001_01_A.png", alt="image 404", position="center") }}

非对称密码相对于对密码, 在加密解密的过程中需要用两个密钥, 一个是可以对所有人公开的公钥, 另一个是只有自己知道的私钥, 一组公钥和私钥组成一个密钥对. 用公钥加密的数据, 只能用对应的私钥解开, 而用私钥加密的数据, 则只能用对应的公钥解开.

{{ image(src="/image/001_02_A.png", alt="image 404", position="center") }}

### 非对称密码-加密解密模式

用公钥加密的数据, 只能用对应的私钥解开, 因为私钥是私密保存的, 所以只有私钥持有者可以解开密文拿到原文, 利用这一点就可以实现数据加密. 

{{ image(src="/image/001_03_A.png", alt="image 404", position="center") }}

比如, 我们想备份文件到共享空间, 又不想让其他人知道文件的内容, 那就可以用公钥对文件加密, 然后把加密的文件保存起来, 后续需要使用文件的时候, 再用私钥解开来就可以了. 再比如, 我们想给别人发送一份文件, 就可以用对方的公钥加密文件, 然后把加密后的文件发送出去. 这样就算加密过的文件被其他人或取了, 由于没有对应的私钥, 也就无法解开得到原文件. 

相比于对称密码, 非对称密码的优势在于不需要事先约定密钥. 设想一下在网络通信中, 要采用对称密码来加密流量的话, 则通信双方在加解密前就需要知道密钥. 如果双方都认识, 或者通信规模不大, 可以通过线下协商等方式来约定好密钥, 但在互联网的情况下, 通信双方通常是互不相识的, 这种方式显然是不适用的, 单靠对称密码无法在不可信的环境下完成安全通信.

{{ image(src="/image/001_04_A.png", alt="image 404", position="center") }}

 而对于非对称密码来说, 公钥是公开的, 可以在发送端用公钥加密数据, 然后在接收端用私钥解密, 整个过程中不需要依赖实现约定的密钥, 所以在不可信的环境下也能实现安全通信. 但非对称密码相对更复杂, 加解密的过程更费时费力, 所以很多时候是把对称与非对称这两种方式结合起来, 比如在访问https的网站时, 先通过非对称加密方式协商出对称密钥, 之后的过程就是借这个对称密钥, 用对称密码的方式通信了.

## 非对称密码-签名验证模式

用私钥加密的数据, 只能用对应的公钥解开, 换个角度说, 如果数据能用某个公钥解开, 那这个文件只能是对应的私钥加密得来的. 私钥是保密的, 只有持有者可以用私钥加密, 所以只能用某私钥生成的数据必然是该私钥持有者生成的; 公钥是对外公开的, 所以任何人都可以用公钥去验证密文是不是用对应私钥加密的, 利用这写特性就可以实现数字签名.

{{ image(src="/image/001_05_A.png", alt="image 404", position="center") }}

比如我们要发布一个软件包, 就用私钥对软件包进行加密得到密文, 然后将密文和原软件包一起发布出去. 因为能够使用这个私钥的只有我们自己, 所以能够生成这个密文的也只有我们自己. 拿到软件包和密文的用户, 就可以用我们的公钥去解开密文, 如果解密的结果和软件包是一样, 那就说明密文确实是我们生成的, 软件包也确实是我们发布的, 密文就相当于是对软件包做了签名, 证明软件包是我们发布的. 

{{ image(src="/image/001_06_A.png", alt="image 404", position="center") }}

上文也提到非对称加密是相对费劲的, 所以在现实情况中, 为了提高效率, 签名通常是对原数据的哈希做加密, 而不是直接对原数据加密. OpenPGP, 许多Linux发行版的包管理系统, PDF的电子签名等等, 都用到了哈希加非对称密码的方式.

*哈希也叫做散列, 杂凑, 消息摘要等, 消息摘要更加形象些, 类比于文章摘要是对一篇文章的概括简述, 消息摘要就是对一段数据的提炼压缩. 常见的哈希算法有MD5, Sha1, Sha2等, 同一种哈希算法对同一文件做计算, 得到的结果是相同的, 而不同的文件计算出来的结果通常是不同的(有概率会相同). 不像文章摘要出来依然是读得通顺的语句, 哈希的结果只是一段二进制数据.*

```bash
// 计算 ABC 的 md5
// 902fbdd2b1df0c4f70b4a5d23525e932
echo -n ABC | md5sum
```

## 数字证书

数字证书也叫做公钥证书(public key certificate), 数字身份(digital identity)等, 从这些名称也可以看出, 数字证书里包含了身份信息和密钥信息. 身份信息可能是个人姓名, 证件号码, 企业名称, 信用代码, 电子邮箱或者域名等待, 密钥信息则包含公钥, 密钥算法, 还有其他额外的属性等. 数字证书的作用就是用来把身份信息和密钥信息关联起来, 也就是用来证明某个密钥是属于某个身份的. 

```
-----BEGIN CERTIFICATE-----
MIIEozCCBEmgAwIBAgIQTij3hrZsGjuULNLEDrdCpTAKBggqhkjOPQQDAjCBjzELMAkGA1UEBhMCR0IxGzAZBgNVBAgTEkdyZWF0ZXIgTWFuY2hlc3RlcjEQMA4GA1UEBxMHU2FsZm9yZDEYMBYGA1UEChMPU2VjdGlnbyBMaW1pdGVkMTcwNQYDVQQDEy5TZWN0aWdvIEVDQyBEb21haW4gVmFsaWRhdGlvbiBTZWN1cmUgU2VydmVyIENBMB4XDTI0MDMwNzAwMDAwMFoXDTI1MDMwNzIzNTk1OVowFTETMBEGA1UEAxMKZ2l0aHViLmNvbTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABARO/Ho9XdkY1qh9mAgjOUkWmXTb05jgRulKciMVBuKB3ZHexvCdyoiCRHEMBfFXoZhWkQVMogNLo/lW215X3pGjggL+MIIC+jAfBgNVHSMEGDAWgBT2hQo7EYbhBH0Oqgss0u7MZHt7rjAdBgNVHQ4EFgQUO2g/NDr1RzTK76ZOPZq9Xm56zJ8wDgYDVR0PAQH/BAQDAgeAMAwGA1UdEwEB/wQCMAAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMEkGA1UdIARCMEAwNAYLKwYBBAGyMQECAgcwJTAjBggrBgEFBQcCARYXaHR0cHM6Ly9zZWN0aWdvLmNvbS9DUFMwCAYGZ4EMAQIBMIGEBggrBgEFBQcBAQR4MHYwTwYIKwYBBQUHMAKGQ2h0dHA6Ly9jcnQuc2VjdGlnby5jb20vU2VjdGlnb0VDQ0RvbWFpblZhbGlkYXRpb25TZWN1cmVTZXJ2ZXJDQS5jcnQwIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLnNlY3RpZ28uY29tMIIBgAYKKwYBBAHWeQIEAgSCAXAEggFsAWoAdwDPEVbu1S58r/OHW9lpLpvpGnFnSrAX7KwB0lt3zsw7CAAAAY4WOvAZAAAEAwBIMEYCIQD7oNz/2oO8VGaWWrqrsBQBzQH0hRhMLm11oeMpg1fNawIhAKWc0q7Z+mxDVYV/6ov7f/i0H/aAcHSCIi/QJcECraOpAHYAouMK5EXvva2bfjjtR2d3U9eCW4SU1yteGyzEuVCkR+cAAAGOFjrv+AAABAMARzBFAiEAyupEIVAMk0c8BVVpF0QbisfoEwy5xJQKQOe8EvMU4W8CIGAIIuzjxBFlHpkqcsa7UZy24y/B6xZnktUw/Ne5q5hCAHcATnWjJ1yaEMM4W2zU3z9S6x3w4I4bjWnAsfpksWKaOd8AAAGOFjrv9wAABAMASDBGAiEA+8OvQzpgRf31uLBsCE8ktCUfvsiRT7zWSqeXliA09TUCIQDcB7Xn97aEDMBKXIbdm5KZ9GjvRyoF9skD5/4GneoMWzAlBgNVHREEHjAcggpnaXRodWIuY29tgg53d3cuZ2l0aHViLmNvbTAKBggqhkjOPQQDAgNIADBFAiEAru2McPr0eNwcWNuDEY0a/rGzXRfRrm+6XfZeSzhYZewCIBq4TUEBCgapv7xvAtRKdVdi/b4m36Uyej1ggyJsiesA
-----END CERTIFICATE-----
```

上面是github.com的一张域名证书, 我们可以先保存到文件, 然后用`openssl x509 -in 文件名 -text`(或者[在线工具](https://www.ssleye.com/ssltool/cer_check.html))来查看证书. 可以看到证书中包含了颁发者(issuer), 持有者(subject, 也就是上文中说的身份信息), 有效期, 公钥信息还有签名信息等内容.

```
// 证书序列号
Serial Number: 4e:28:f7:86:b6:6c:1a:3b:94:2c:d2:c4:0e:b7:42:a5
// 签名算法
Signature Algorithm: ecdsa-with-SHA256
// 证书颁发者
Issuer: C=GB, ST=Greater Manchester, L=Salford, O=Sectigo Limited, CN=Sectigo ECC Domain Validation Secure Server CA
// 证书有效期
Validity
  Not Before: Mar  7 00:00:00 2024 GMT
  Not After : Mar  7 23:59:59 2025 GMT
// 证书持有者
Subject: CN=github.com
// 持有者公钥信息
Subject Public Key Info:
  Public Key Algorithm: id-ecPublicKey
  Public-Key: (256 bit) ...
```
 
前文中提到, 公钥可以验证数字签名, 而数字证书里包含了公钥, 所以数字证书也可以用来验证签名. 而且由于数字证书把密钥和身份关联了起来, 所以数字证书不仅可以验证签名是否正确, 而且在签名正确的情况下还可以知道这个签名是谁签的, 这样我们就不必记住哪个公钥是属于谁的, 从数字证书里就能拿到直观的身份信息. 

还是用发布软件的例子，这里假设我们有了一张数字证书. 在发布软件时, 把证书和签名也一起发布出去. 用户获取到发布的软件后, 就可以先拿证书里的公钥去验证签名是不是匹配, 如果签名和公钥对得上, 再看一下证书里的身份信息, 就可以知道这个软件包是谁发布的了. 以前没有软件商店这类的应用时, 经常需要自己去下载软件, 下载后要核验是不是官方的, 就可以验证软件签名里的身份对不对, 到现在这些验证工作通常由商店应用代劳了.

那么证书是怎么来的呢, 事实上任何人都可以通过证书工具(比如openssl)来生成证书. 上面说到证书关联了密钥信息和身份信息, 那岂不意味着任何人都可以对这两者做关联？如果我们把自己的密钥信息和别人身份信息绑在一起生成一张证书, 岂不是可以冒充去发布软件包了？是的, 这样的证书是可以生成的, 不过没有什么用, 因为对其他人来说这证书是不可信的, 其他人“只”会信任CA机构颁发的证书. 

## CA机构与自建CA

CA的全称是Certificate Authority, 即证书授权中心, 负责证书的管理和颁发. CA在核实了密钥信息和身份信息后, 才会对这些信息做数字签名, 然后把密钥, 身份和签名信息放一起生成数字证书. 

CA是中心化, 权威性的服务, 普通用户对CA"默认"信任, CA的可信来源于权威的背书, 而不是逻辑的证明. 用户对于CA签发的证书, 认为是有效的可信的, 也就是说如果遇见CA签发的证书, 就相信这证书里的密钥是属于证书里的身份的. 

```
Issuer: C=GB, ST=Greater Manchester, L=Salford, O=Sectigo Limited, CN=Sectigo ECC Domain Validation Secure Server CA
Signature Algorithm: ecdsa-with-SHA256
Signature Value: ...
```

上文用openssl解析github.com域名证书的结果中, 我们也可以看到签名相关的信息. 我们之所以信任这张证书, 是基于两点原因:

1. 证书是CA颁发的的, 而我们是选择信任这个CA的
2. 证书的签名是正确的, 证明CA核验过了密钥和身份

自建CA和权威CA的功能一样, 都是管理颁发证书, 只不过自建的CA没有权威性, 不会被其他人信任. 但也不是没有用武之地, 比如, 家庭局域网内, 设备都是自家的, 当然可以自己签发证书, 然后让他们互相信任, 有些智能家居协议就是这样实现的. 再比如公司内部, 如果用权威CA来发证书的话, 可能要付出一笔费用, 这时候就可以考虑自建公司内部的CA, 给相关人员发证书. 

{{ image(src="/image/001_07_A.png", alt="image 404", position="center") }}

不是权威CA就是可信的, 权威CA也可能会失职, 甚至可能会丢失密钥, 而且一旦发生造成, 所危害是相当大; 也不是非权威CA就是不可信的, 有些信誉可靠, 办事严谨的机构, 用户也可以选择信任他们. 所以信任哪些CA不是固定不变的, 在Firefox浏览器(**设置->隐私与安全->证书->查看证书->证书颁发机构**), Adobe Acrobat Reader(pdf阅读器)等软件中, 信任的CA都是可配置的. 

## 根证书和证书链

上文里提到数字证书里是包含了证书颁发者的签名的, 如果此处证书的颁发者和持有者是同一个身份, 也就是说, 证书是自己颁发给自己的, 自己证明自己有效, 这样的证书就是根证书, 也叫做自签证书, 因为它不需要其他证书来证明, 是自己给自己做的签名. 

CA机构的顶级证书通常是自签证书, 因为他们有效性不是他方证明的, 而是“权威”保证的. 我们也可以生成自己的自签证书, 然后用这样的根证书来自建CA. 

那证书链又是什么呢？设想某个机构拿到了签发证书的资质, 也就有权威的根证书了, 但核验身份和管理证书这些事不想自己去做, 而是想交给信任的子机构去做. 这时候, 就可以先签发一张中级证书给子机构, 赋予次级证书可以颁发其他证书的功能, 然后子机构就可以再去签发下级证书. 这样, 根证书, 中级证书, 下级证书, 一级信任一级, 就像链条一节扣一节, 串联起来就构成了证书链. 

{{ image(src="/image/001_08_A.png", alt="image 404", position="center") }}

比如我们用Firefox打开https://github.com, 然后点击地址栏旁边的小锁, 选择**安全链接->更多信息->安全->查看证书**, 就可以看到github.com的证书链了. 上图中左边的`github.com`是下级证书, 中间的`Sectigo ECC Domain Validation Secure Server CA`是中级证书, 右边的`USERTrust ECC Certification Authority`是根证书. 这里可以看到, 下级证书的颁发者是中级证书, 中级证书的颁发者是根证书, 中级证书的**密钥用途**中有一项Certificate Signing, 代表这张中级证书被赋予了签发下级证书的能力.

根证书到最终的证书之间, 也可能会间隔多张中级证书, 因而证书链的长度也不是固定的. 要校验最终证书的有效性, 则需要先校验最终证书的上级证书, 再校验上上级, 一直校验到根证书为止. CA机构也可能会出于其他的原因签发中级证书, 比如不同场景, 或者不同的年份, 或者不同的地域, 由不同的中级证书负责签发. 

## CRL和OCSP
 
就像身份证的挂失机制一样, 除了写在证书里的有效期信息, CA还提供了吊销证书的方式, 能够让证书提前失效. 但因为已经发出去的证书本身在吊销前后并不会有区别, 所以CA得提供实时查询证书状态的服务, 这就是CRL和OCSP, 数字证书里也包含的服务的地址信息.

```
Authority Information Access:
  CA Issuers - URI:http://crt.sectigo.comSectigoECCDomainValidationSecureServerCA.crt
  OCSP - URI:http://ocsp.sectigo.com
```

CRL的全称是Certificate Revocation List, 即证书吊销列表, OCSP的全称是Online Certificate Status Protocol, 即在线证书状态协议, OCSP解决了CRL存在的一些问题, 可以看做是替代CRL的更先进的方式. OCSP响应本身也是包含签名的, 相对于是CA证明了此时证书是有效的. 

PDF开启长期签名验证(LTV)时, 会把OSCP结果写入签名中, 这就证明了在生成这个数字签名时, 该证书确实是有效的. 设想假如我们的私钥失窃了, 那么拿到私钥的人就可以冒充我们去做数字签名. 这时如果我们请求CA吊销原来的证书, 那么冒充者在数字签名时就无法获得有效的OCSP相应, 也就是无法让CA证明此时证书依然是有效的. 而且冒充者无法再通过CA的身份审核拿到新的证书, 就无法证明这对密钥还是我们的, 所以也就无法继续冒充了. 

## 长期证书和事件证书
就像很多食品包装上印有生产日期和保质期一样, 证书里包含了证书的有效期, 开始时间(not before time)和结束时间(not after time), 在这个有效时间段内这张证书才是有效的. 事件证书就像即时食品, 有效期很短, 通常是证书颁发出来后马上使用, 不会再重复使用, 一张证书用来做一件事, 因而叫做事件证书. 例如在使用一些软件时, 会需要先同意某些协议, 在同意这个过程中很可能就有事件证书发挥了作用. 长期证书的有效期比较长, 可以多次使用. 像域名证书, 企业法人证书, 网络通讯证书等一般都是长期证书. 

## 可信时间戳
类似于数字证书是把身份和密钥信息关联起来, 可信时间戳是把时间和数据信息关联在一起, 也就是用来证明某个时间点存在某个数据, 类似于提供证书服务的CA, 可信时间戳服务也是一种权威性的中心化服务. 数字签名可以证明某个密钥产生了某个数据, 数字证书可以证明某个密钥是属于某个身份的, 可信时间戳则可以证明某个时间有某个数据, 把这些结合起来, 就可以证明某个身份在某个时间产生了某个数据了(比如电子签名中, 就是谁在什么时间签署了什么文件).

## CSR
CSR证书签发请求, 全称是Certificate Signing Request, 如果我们想去CA那申请数字证书, 就向需要CA提交CSR, CSR里面包含了身份信息和密钥信息, CA核验身份后就可以根据CSR里的信息签发证书了. 

## 相关命令

1. 生成RSA私钥, 密钥长度为2048位, 保存到private-key  
`openssl genrsa -out private-key 2048`

2.  根据私钥生成公钥, 保存到public-key  
`openssl rsa -in ./private-key -pubout -out public-key`

3. 根据私钥生成CSR, 保存到example01.csr  
`openssl req -new -key ./private-key -out example01.csr`

4. 根据CSR生成自签证书, 保存到example01.crt  
`openssl x509 -req -in example01.csr -out example01.crt -signkey ./private-key -days 3650`

5. 查看证书信息  
`openssl x509 -in example.crt -text`

6. 用根证书颁发证书  
`openssl x509 -req -in example02.csr -days 365 -CA example01.crt -CAkey private-key -CAcreateserial -out example02.crt`

