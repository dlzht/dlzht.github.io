+++
title = "Rust异步1: 为什么需要异步"
date = 2024-04-30
[taxonomies]
tags = ["Rust", "异步"]
+++

这篇文章采用一问一答的形式, 主要介绍Rust异步相关的"基础"问题. "异步编程, 是一种越来越多语言都提供支持的并发模型, 可以让你在少量的系统线程上并发处理大量的任务, 而且借由async和await语法, 有着和同步一样的编程体验". 这是[async-book](https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html#why-async)里的一段话, 我们的文章也由此开始.

<!-- more -->

> Asynchronous programming, or async for short, is a concurrent programming model supported by an increasing number of programming languages. It lets you run a large number of concurrent tasks on a small number of OS threads, while preserving much of the look and feel of ordinary synchronous programming, through the async/await syntax.

Q: Rust的异步(async, 下文用Future指代)指的是什么?

A: 异步是编程语言提供的并发编程模式.

---

Q: 所以Future是Rust提供给开发者, 用来在程序中实现并发的一种方式, 是这样吗?

A: 是的, 标准库提供了async/await关键字和Future特征, 第三方库则提供运行时实现和相关的工具组件

---

Q: 并发模型, 并发又是什么?

A: [并发](https://en.wikipedia.org/wiki/Concurrent_computing)与串行相对, 指可以同时进行多个任务, 而不必等到上一个任务完成再进行下一个. 

比如我们的web服务是这样处理请求的: *接收请求 -> 处理过程 -> 返回响应*

串行模式: *接收请求A -> 处理过程A -> 返回响应A -> 接收请求B -> 处理过程B -> 返回响应B*

并发模式: *接收请求A -> 处理过程A -> 接收请求B -> 处理过程B -> 返回响应B -> 返回响应A*

上面只是并发模式下一种可能的情况, 这里想说明的是A和B两个任务在时间上可以有重叠的部分, 也就是我们可以同时进行A与B两个任务.

---

Q: 并发对我们有什么用呢?

A: 简单地说是为了提高程序的运行效率. 还是上面web服务器的例子, 假设第二步 *处理过程* 是任务等待(休眠)1秒, 第一和第三步的耗时忽略不计. 如果是串行模式, 处理两个请求就大概需要2秒, 而并发模式下只需要1秒, 甚至在一定程度内, 处理n个请求, 串行要n秒, 而并发还是要1秒.

---

Q: 看上去效率确实提高了, 并发是怎么做到这一点的?

A: 秘诀在于让CPU(这边我们只考虑单核)尽可能地忙碌起来. 上面的 *处理过程* 是休眠1秒, 当第一个A任务到了休眠这一步, 在串行模式下就意味这CPU无事可做了, 而在并发模式下, CPU还可以去执行B任务. 当B任务也到了需要休眠这一步, CPU确实只能空等了, 但此时A与B在同时休眠, 1秒钟后两个响应就都能返回, 所以处理两个请求需要差不多1秒. 

---

Q: 也就是说, 并发是把CPU空闲的时间利用起来了, 对吗?

A: 是的, 如果第二步处理过程中也需要CPU一直工作, 比如计算一个很复杂的方程, 那并发就没什么作用了. 而且并发实现本身也是有开销的, 如果CPU已经很忙了, 再用并发也不一定划算. 不单单是CPU, 很多资源比如磁盘, 也是一样的情况, 不过以CPU来说明问题也足够.

---

Q: 但我的程序并没有sleep(休眠), 是不是并发对我就没用了?

A: 除了sleep调用, 文件相关的, 网络相关的, 各种锁, 互斥量以及信号等等操作, 都会让我们的任务停下来, 我们也把这些操作叫做同步或者阻塞调用(不那么严谨). 比如下载一个网络文件的过程中, DNS解析, 发送网络请求, 接收数据响应, 保存到文件, 这些都会让任务停顿. 同步调用是如此的普遍, 相对部分的程序都要与之打交道, 所以并发的重要性也愈发的凸显.

---

Q: 如果我不用Rust了, 换成其他语言, 比如C, 还需要考虑并发相关的问题吗?

A: 这些同步调用究其根源是操作系统提供的, 包括Linux, Windows, Unix等等, 任务停下来表现为系统线程的阻塞. 我们的程序一方面通常都运行在操作系统之上, 另一方面又通常需要文件和网络这些功能, 可以说"无论"用什么语言都无法避开. 也许在某些语言中开发者基本不用关注, 比如Go, 因为语言已经封装好然后隐藏起来了, 但有些问题依然是需要考虑的(比如GOMAXPROCS).

---

Q: 操作系统提供的这些调用为什么是同步的呢?

A: 一方面, 比如读取终端输入这类的操作是不确定的事件, 我们不知道什么时候用户会完成输入, 处理这样的事件"等待"似乎没法避免; 另一方面, 早期时代的CPU还是单核的, 程序也远没有现在这么复杂, 串行的设计也是合理的. 虽然时至今日情况已大为不同, 但要摆脱历史的包袱并不容易, 当年的设计和实现依然在影响我们. 事实上, 我们处在一个同步与异步并存的时期, 还存在很多问题, 还有很多工作要做.

---

Q: 也就是说操作系统也提供异步的调用了吗?

A: 是的, 系统提供了异步的方式(比如Linux下的O_NONBLOCK, epoll, io_uring这些内容), 这也是编程语言可以提供并发模型的基础. 坏消息是目前并不完美, 好消息是一切都在改善中.

---

Q: 下载网络文件, 我好像也做过, 好像还用了什么多线程?

A: 是的, 多线程是操作系统提供的并行模型, 可以用这种方式实现并发. 在多线程的模式下, 我们把任务分散到不同的线程里去处理, 虽然我们的任务依然会停下来(线程会阻塞), 但此时操作系统会进行线程调度, 切换到其他线程去处理另外的任务, 任务之间是并发的. 线程是操作系统提供的, 而且绝大多数语言都会支持系统线程, 所以多线程的并发模型最为广泛.

---

Q: 这种方式听起来也不错, 为什么Rust还要提供Future的并发模型呢?

A: 多线程模式有兼容性好, 易于上手, 容易理解等等优势, 所以Rust也是支持这种模式的, 一个`std::thread::spawn(|| { ... })`方法就可以开启多线程了. 但多线程模式也有缺点, 主要有两点, 一是系统线程需要占据很大的内存空间, 二是线程竞争和切换会带来开销. 这使得我们不能创建太多的线程, 也就在某些情况下限制了我们的并发数, 而Future方案可以解决相当一部分问题.

---

Q: 除了多线程和Future, 还有其他的并发模型吗?

A: 当然, 比如Erlang的Actor模型, Go的Goroutine协程模型, JS的事件驱动模型等等. 模型本身是不限于用哪种语言实现的, 也不限于在哪里实现, 不过这些语言比较有代表性.

---

简单总结一下:

1. 并发是同时处理多个任务, 可以提高程序的运行效率, Rust提供了Future的并发模型
2. 同步调用是单线程很难并发的原因, 线程会阻塞在调用上, 而且这些调用是系统提供的
3. 多线程可以用来实现并发, 操作系统会进行线程调度, 但存在内存占用和竞争切换问题

还可以从阻塞粒度的角度来看串行, 多线程和Future这三种模式, 上面说到, 要处理读取终端输入或者接收网络数据这类不确定的事件, 等待似乎是必然的. 但"谁"去等待, 是CPU核心, 还是系统线程, 还是用户任务, 阻塞的粒度是可以变化的.

串行模式下, 任务陷入等待, 线程也被阻塞了, CPU核心也被阻塞了; 多线程模式下, 任务陷入等待, 对应的线程会阻塞, 但CPU核心可以运行其他线程; 而由于系统线程带来的开销, 所以Future的出发点就是进一步缩小阻塞粒度, 只阻塞用户任务本身, 而线程和CPU核心都可以去做其他事情. 这和锁的优化过程很像, 通过对粒度控制, 提高程序的效率.

</br>

*-> 如果文章有不足之处或者有改进的建议，可以发表到[这边](https://github.com/dlzht/dlzht.github.io/discussions/5)，也可以联系我的[邮箱](mailto:dlzht@protonmail.com)，感谢阅读*