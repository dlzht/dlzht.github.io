+++
title = "Rust时间日期库 Jiff"
date = 2024-07-25
[taxonomies]
tags = ["Rust", "lib"]
+++

每个程序员都会处理时间的场景, 或多或少地要和时间库打交道. 之前写Java时, 尽管`LocalDateTime`, `LocalDate`已经出现很多年了, 但老旧的`Date`还是大行其道(哪怕是在新项目中). 项目停留在"能跑就行"可以, 但程序员可不能停下来, 这就来看看计算机里的时间是怎么回事.

<!-- more -->

## 时间是怎么度量的

虽然我们不清楚时间是从哪里开始的, 流逝的方向又是什么, 但聪明的"我们"依然找到了度量时间的方式, 关键在于找到度量的单位.

{{ image(src="/image/014_01.png", alt="image 404", position="center") }}

质量的度量单位千克, 我记得之前教科书上有张"国际千克原器"的图, 就是放在钟形容器的那块砝码. 这块砝码就是质量的度量单位, 要称量其他物品时, 只要知道物品有几个砝码那么重就可以了. 

时间的度量也是如此, 我们只要找到度量的单位, 然后其他任意时间段的长度, 只要和这个单位比较一下就知道了. 我们找到的时间度量单位, 是很多周期性的事件.

地球公转一周, 就有一年; 地球自转一圈, 就有一天. 为了更精确地表达时间, 再把这些度量单位进一步地细化切分, 1天分成24小时, 1小时再分成60分钟, 1分钟再分成60秒, 1秒再分成...

`2024-01-01 02:03:09`, 这样 日期+时间 的格式, 是全球范围内都广泛使用的时间表达形式, 被称为本地时间. PlainTime, CivilTime, NativeTime, LocalTime等等, 在代码会遇到不同的名称, 大差不差, 它们都是指这种时间格式. 

## 计算机里的时间

{{ image(src="/image/014_02.png", alt="image 404", position="center") }}

来到计算机世界, 很多机器都会配有硬件时钟. 硬件时钟的本质在于, 以晶体周期性的振荡为度量单位, 即振荡一次相当于多少秒是确定的, 只有知道振荡过的次数就可以换算到我们需要的时间. 因为晶体振荡的频率很高, 所以硬件时钟的精度要远高于秒.  

Linux下, 可以用`hwclock`命令来查看或配置硬件时钟. 硬件时钟通常有单独的电池供电, 所以即使电脑关机, 或者拔掉电源后, 也能继续工作. 下次开机的时候, 系统还能显示正常的时间.

计算机除了根据自己的硬件来维护时间, 还能通过网络时间协议NTP(Network Time Protocol)来校正. NTP的时间源头是全世界几百台原子钟的共识, 它们共同决定了秒的"长度", wiki上给出的近代原子钟的精度大概是2*10<sup>-16</sup>.

如此广泛的共识, 加上如此高的精度, 我只能说牛, 确实厉害了. Arch/Linux的NTP配置可以参考[Network_Time_Protocol_daemon](https://wiki.archlinux.org/title/Network_Time_Protocol_daemon). windows的话在日期时间配置面板上, 勾选`与Internet时间服务器同步`就可以了.

NTP通过网络把"标准"时间传递出去, 大大小小的计算机就校准自己的时间, 得到一个"准确"的时间了. 当然, 由于网络延迟等因素的存在, 虽然NTP同步时有考虑到这些, 但最终校准出来的时间肯定会丢失很多精度.

```c
int clock_gettime(clockid_t clockid, struct timespec *tp);

struct timespec {
  time_t   tv_sec;   // 秒
  long     tv_nsec;  // 纳秒
};
```

在Linux系统上, 我们可以通过系统调用`clock_gettime`获取当前的系统时间. 返回的`timespec`里的字段, 指的是从`Epoch`(1970-01-01 00:00:00Z)开始到现在经历的秒和纳秒数, 这就是我们熟悉的时间戳了.


```rust
pub fn now() -> Timestamp {
  Timestamp::try_from(std::time::SystemTime::now()).expect("system time is valid")
}

// https://www.manpagez.com/man/3/clock_gettime/
pub fn now() -> Instant {
  const clock_id: libc::clockid_t = libc::CLOCK_MONOTONIC;
  Instant { t: Timespec::now(clock_id) }
}

pub fn now() -> SystemTime {
  SystemTime { t: Timespec::now(libc::CLOCK_REALTIME) }
}
``` 
`jiff`库里获取当前时间的`Timestamp::now`, 调用的是标准库里的`SystemTime::now`. 而标准库里的`Instant::now`和`SystemTime::now`, 底层正是调用了`clock_gettime`.   

## 时间戳到本地时间

时间戳被定义为从`Epoch`开始到某个时刻经历的秒数, 因为起点和秒的"长度"大家是达成了共识的, 所以时间戳在某个时刻, 对所有人来说都是一样的, 我们可以把时间戳看作是"绝对"时间.

操作系统和编程语言也为我们提供了获取时间戳的方法, 但为了方便大家使用, 毕竟计算机还要给人用, 我们还需要能将时间戳转换到本地时间的方法, 这问题就来了.

因为本地时间是偏向自然规律的, 比如太阳7:00升起, 中午是12:00, 中国人是这样认为的, 美国人也是这样认为的. 但对于某个具体的时刻, 比如中国在白天(7:00), 此时美国却是晚上(19:00).

显然, 时间戳没办法直接转换到本地时间, 这边的问题在于地球绕着地轴转, 不同地区的日出日落时间不一样, 同一个时间戳时刻对不同地区的人, 显示的本地时间是不同的.

既然知道了问题在于地区, 解决的办法也就有了. 只要地球还是绕着地轴转, 那同一经线上的本地时间就是相同的, 而不同经线上的时间偏差是可以计算出来的, 由此就有了带时区的时间.

## 固定偏移时区

上面我们提到`Epoch`的时候, 给出的是时间`1970-01-01 00:00:00Z`. 这其实是一个带时区的时间, 注意最后的字母`Z`, 表示这个时间是本初子午线这条经线上的, `Z`就是时区信息. 

也就是说, 时间戳的定义, 已经包含了和某条经线上本地时间的关系. 地球自转360<sup>°</sup>是1天, 那很容易计算, 经线相隔15<sup>°</sup>就会差1个小时, 相隔1/4<sup>°</sup>就会差1分钟, 这就是固定偏移的来源.

```text
1970-01-01T01:00:00+00:00  3600

1970-01-01T02:30:00+01:30  3600
\________/ \______/ \___/
    |         |       |
   日期       时间   偏移(时区)
```

如上是两个固定偏移时区的时间, 都对应`3600`这个时间戳. 第一个时间的偏移量是0, 也就是在"原点"上, 这个时区通常也被称为UTC时区(`TimeZone::UTC`).

第二个时间的偏移量是01:30, 偏移量 + UTC时区时间 = 当前时间, 也就是 01:00 + 01:30 = 02:30. 偏移量的范围在-12:00 ~ +14:00, 区间长度是26, 竟然不是24小时, 原因可以看一下[UTC+14:00](https://en.wikipedia.org/wiki/UTC%2B14:00).

## POSIX时区

POSIX格式的时区本身用的并不多(基本没见过..), 不过这种格式有包含了夏令时相关的内容, 所以也列在这边了, 顺便也了解下夏令时的概念.

```text
STD offset [ DST [ dstoffset ] [ , rule ] ]

STD:        夏令时没开启时时区名称的缩写
offset:     UTC偏移
DST:        夏令时开启后时区名称的缩写(可选)
dstoffset:  夏令时的UTC偏移(可选)
rule:       夏令时规则(可选)
```

夏令时, Daylight Saving Time`，简称为`DST`. 一般在春夏季开启, 秋冬季退出. 在夏令时开启时, 会把时钟调快, 比如向前拨1个小时, 这样本来的07:00, 就变成了08:00. 这样做的原因是, 夏季天亮的更早, 对于日出而作的我们, 能更多地利用太阳光照, 降低能源消耗.

```text
EST05:00EDT,M3.2.0/2:00:00,M11.1.0/2:00:00
\_/\___/\_/ \____________/ \_____________/
 |   |   |        |               |
时区 偏移 时区  夏令时开启时间   夏令时结束时间
```

上面是纽约的POSIX时区的示例, 没开启夏令时, 采用时区`EST`时区(UTC-05:00, POSIX规定里的东西方向和UTC相反); 开启夏令时后, 采用`EDT`时区. 夏令时开启的时间是3月份第2个星期日的02:00, 结束的时间是11月份第1个星期日的02:00.

```rust
let d1 = DateTime::constant(2024, 3, 10, 1, 59, 59, 0)
    .intz("America/New_York").unwrap();
let d2 = d1.add(1.second());

// d1: 2024-03-10T01:59:59-05:00[America/New_York]
// d2: 2024-03-10T03:00:00-04:00[America/New_York]  
```

夏令时给程序带来了麻烦, 比如上面的例子中. `d1`是进入夏令时的前一刻, `d1`加上一秒到了`d2`, 明明只过了1秒, 时间上却差了1个小时, 不了解夏令时的同学肯定会非常困惑(例如我~).

对于纽约来说, `2024-03-10 02:00:00 ~ 2024-03-10 03:00:00`这段时间成了"空白", 没有时间戳会解析在这个时间段里, 这被称为`gap`.

而退出夏令时时, 比如`2024-11-03 01:00:00 ~ 2024-11-03 01:00:00`, 这段时间会重复一遍, 其中任意时间点, 也就会被两个时间戳对应到, 这被称为`fold`.

我国在1986也实行过夏令时制, 实行了6年, 到1992年暂停了, 因为节电效果并不好, 而且给工业生产和日常生活带来了很多麻烦, U_U.

## TZif格式时区

对于固定偏移的时区来说, 怎么推算某个地区的时间, 是非常容易理解的, 实现起来也简单. 但现实总不那么简单美好. 一方面地区很少是按经线划分的, 国家或州省的形状并不规整; 另一方面, 时区和夏令时规则是随时会改变的, 而且从实际看这种改变并不罕见.

这些时区规则不是既定的逻辑, 而是随时可能会变化的, 更像是一个会更新添加记录的数据库, 所以诞生了[Time Zone Database](https://www.iana.org/time-zones)时区信息数据库. 数据库里包含国家和地区的时间规则 当国家和地区发生变更, 或者政府宣布变更时间规则时, 这些变更记录也会被更新到数据库中.

```text
// /usr/share/zoneinfo/America/New_York     
Sun Mar 10 06:59:59 2024 UT = Sun Mar 10 01:59:59 2024 EST isdst=0 gmtoff=-18000
Sun Mar 10 07:00:00 2024 UT = Sun Mar 10 03:00:00 2024 EDT isdst=1 gmtoff=-14400
Sun Nov  3 05:59:59 2024 UT = Sun Nov  3 01:59:59 2024 EDT isdst=1 gmtoff=-14400
Sun Nov  3 06:00:00 2024 UT = Sun Nov  3 01:00:00 2024 EST isdst=0 gmtoff=-18000
```

Linux通常自带了时区数据库, 比如Arch系统, 我们可以用命令`zdump -v /etc/localtime`查看当前配置下的时区信息, 而其他时区的文件在`/usr/share/zoneinfo/`目录下可以找到, 如上是纽约时区2024年的相关信息.

JDK也带有时区数据库, 比如1.8版本的`jre/lib/tzdb.dat`文件. rust的时间处理库chrone, 有不同的方法应用时区数据库, 例如[tzfile](https://github.com/kennytm/tzfile)是读取系统的数据库文件, 而[chrone-tz](https://github.com/chronotope/chrono-tz)是读取打包进二进制包里的数据库文件.


## 小结

这篇文章主要讲述了计算机时间相关的内容, 起因是rg的作者[BurntSushi](https://github.com/BurntSushi)新发布了[jiff](https://github.com/BurntSushi/jiff)这个时间库, 项目里的文档[DESIGN.md](https://github.com/BurntSushi/jiff/blob/master/DESIGN.md)和[COMPARE.md](https://github.com/BurntSushi/jiff/blob/master/COMPARE.md)非常值得一读, 设计和开发一个好用的时间库并不容易, 后面也打算继续写一下相关的文章.

</br>

*-> 如果文章有不足之处或者有改进的建议，可以在[这边](https://github.com/dlzht/dlzht.github.io/discussions/12)告诉我，也可以发送给我的[邮箱](mailto:dlzht@protonmail.com)*