<!DOCTYPE html>
<html lang="en">

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q8CTC2C6DM"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-Q8CTC2C6DM');
    </script>

    <title></title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://dlzht.github.io/style.css">
    <link rel="stylesheet" href="https://dlzht.github.io/color/blue-light.css">

        <link rel="stylesheet" href="https://dlzht.github.io/color/background_light.css">
    
    <link rel="stylesheet" href="https://dlzht.github.io/font-hack-subset.css">

    <meta name="description" content="">

    <meta property="og:description" content="">
    <meta property="og:title" content="">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://dlzht.github.io/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="">
    <meta name="twitter:title" content="">
    <meta property="twitter:domain" content="dlzht.github.io">
    <meta property="twitter:url" content="https://dlzht.github.io/">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://dlzht.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            QianQi dlzht@protonmail.com
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://dlzht.github.io">主页</a></li>
            
                <li><a href="https://dlzht.github.io/tags">标签</a></li>
            
                <li><a href="https://dlzht.github.io/about">关于</a></li>
            
                <li><a href="https://dlzht.github.io/archive">归档</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
        <div class="posts">
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://dlzht.github.io/011-zou-ma-guan-hua-httpku-2/">走马观花http库2</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-07-03
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/rust/">#Rust</a>&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/http/">#http</a>&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/hyper/">#hyper</a></span>
    


                    
        <div class="post-content">
            <p>HeaderMap是http库里用来处理协议头的结构, 本质上是一个哈希表, 解决哈希冲突的策略是开放地址, 地址探测采用的是<a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Hash_table#Robin_Hood_hashing">robin hood</a>. 因为是专用于http头的场景, 还具有键不区分字母大小写, 一个键可以对于多个值, 可以在快速哈希和安全哈希间切换等特点.</p>

        </div>
        <!-- <div> -->
            <!-- &#xFE0E; -- force text style - some devices render this as emoji -->
            <!-- <a class="read-more button" href="https://dlzht.github.io/011-zou-ma-guan-hua-httpku-2/"> -->
                <!-- <span class="button__text">Read more</span>&nbsp; -->
                <!-- <span class="button__icon">&#8617;&#xFE0E;</span> -->
            <!-- </a> -->
        <!-- </div> -->
    

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://dlzht.github.io/010-zou-ma-guan-hua-httpku-1/">走马观花http库1</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-06-28
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/rust/">#Rust</a>&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/http/">#http</a>&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/hyper/">#hyper</a></span>
    


                    
        <div class="post-content">
            <p><a rel="noopener" target="_blank" href="https://github.com/hyperium/http">http库</a>是用Rust编写的一个http基础库, 实现了Request, Response, Method等数据结构. <a rel="noopener" target="_blank" href="https://github.com/hyperium/hyper">hyper</a>是基于http库的, 而目前Rust的绝大多数web框架都基于hyper, 所以http库几乎是http协议在Rust中的&quot;标准实现&quot;.</p>

        </div>
        <!-- <div> -->
            <!-- &#xFE0E; -- force text style - some devices render this as emoji -->
            <!-- <a class="read-more button" href="https://dlzht.github.io/010-zou-ma-guan-hua-httpku-1/"> -->
                <!-- <span class="button__text">Read more</span>&nbsp; -->
                <!-- <span class="button__icon">&#8617;&#xFE0E;</span> -->
            <!-- </a> -->
        <!-- </div> -->
    

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://dlzht.github.io/009-redis-shi-jian-xun-huan/">从redis源码讲事件循环</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-05-18
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/redis/">#redis</a>&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/yi-bu/">#异步</a></span>
    


                    
        <div class="post-content">
            <p>redis是用C实现的, 事件循环部分简洁而优雅, 代码也紧凑而独立, 不仅能比较流畅地阅读, 而且能很方便地引用到项目中, 压测工具<a rel="noopener" target="_blank" href="https://github.com/wg/wrk/blob/master/src/ae.c">wrk</a>就使用了这部分代码. 下面我们就开始介绍redis中事件循环的实现.</p>

        </div>
        <!-- <div> -->
            <!-- &#xFE0E; -- force text style - some devices render this as emoji -->
            <!-- <a class="read-more button" href="https://dlzht.github.io/009-redis-shi-jian-xun-huan/"> -->
                <!-- <span class="button__text">Read more</span>&nbsp; -->
                <!-- <span class="button__icon">&#8617;&#xFE0E;</span> -->
            <!-- </a> -->
        <!-- </div> -->
    

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://dlzht.github.io/008-yi-wen-goshi-zen-yao-chu-li-zhan-de/">译文: Go是怎么处理栈的</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-05-15
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/yi-bu/">#异步</a>&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/yi-wen/">#译文</a></span>
    


                    
        <div class="post-content">
            <p>这是一篇翻译文章, 原文是<a rel="noopener" target="_blank" href="https://blog.cloudflare.com/how-stacks-are-handled-in-go">How Stacks are Handled in Go</a>(by <a rel="noopener" target="_blank" href="https://blog.cloudflare.com/author/daniel">Daniel Morsing</a>). 这篇文章向我们介绍了Go解决协程栈增长问题的两种方式和他们的优缺点, 可以帮助我们了解异步模型中有栈还是无栈(Rust的Future是无栈)的考虑出发点.</p>

        </div>
        <!-- <div> -->
            <!-- &#xFE0E; -- force text style - some devices render this as emoji -->
            <!-- <a class="read-more button" href="https://dlzht.github.io/008-yi-wen-goshi-zen-yao-chu-li-zhan-de/"> -->
                <!-- <span class="button__text">Read more</span>&nbsp; -->
                <!-- <span class="button__icon">&#8617;&#xFE0E;</span> -->
            <!-- </a> -->
        <!-- </div> -->
    

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://dlzht.github.io/007-rust-yi-bu-04/">Rust异步4: Pin和自指类型</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-05-12
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/rust/">#Rust</a>&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/yi-bu/">#异步</a></span>
    


                    
        <div class="post-content">
            <p>在前面介绍Future模式的文章里, 简单讲了下poll方法里的入参Pin类型, 引入Pin是为了解决自指类型的问题, &quot;固定&quot;Future在内存中的位置. 这篇文章就来介绍自指类型是什么, 和Future有什么关系以及Pin是如何解决问题的这些内容.</p>

        </div>
        <!-- <div> -->
            <!-- &#xFE0E; -- force text style - some devices render this as emoji -->
            <!-- <a class="read-more button" href="https://dlzht.github.io/007-rust-yi-bu-04/"> -->
                <!-- <span class="button__text">Read more</span>&nbsp; -->
                <!-- <span class="button__icon">&#8617;&#xFE0E;</span> -->
            <!-- </a> -->
        <!-- </div> -->
    

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://dlzht.github.io/006-rust-yi-bu-03/">Rust异步3: async&#x2F;await语法</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-05-10
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/rust/">#Rust</a>&nbsp;
                <a class="post-tag" href="https://dlzht.github.io/tags/yi-bu/">#异步</a></span>
    


                    
        <div class="post-content">
            <p>上一篇<a rel="noopener" target="_blank" href="https://dlzht.github.io/005-rust-yi-bu-02/">Future模型</a>中介绍了Future模式是如何工作的, 我们开发异步程序时只要实现Future, 然后交给runtime去推动就可以了. 虽然状态机实现的Future, 具有内存占用少, 执行效率高等优点, 但也存在一些问题, 比如:</p>
<ol>
<li>异步代码要考虑让出和继续, 和同步代码的线性编程方式很不同</li>
<li>状态机的执行依赖于状态的变更, 程序越复杂, 状态维护越困难</li>
<li>需要经常和生命周期, Pin等晦涩的概念打交道, 编程门槛不低</li>
</ol>
<p>为了缓解Future模式带来的复杂性, 也为了能和同步编程有相似的体验, Rust提供了async和await关键字, 下面我们就来看看这两个语法糖具体做了什么.</p>

        </div>
        <!-- <div> -->
            <!-- &#xFE0E; -- force text style - some devices render this as emoji -->
            <!-- <a class="read-more button" href="https://dlzht.github.io/006-rust-yi-bu-03/"> -->
                <!-- <span class="button__text">Read more</span>&nbsp; -->
                <!-- <span class="button__icon">&#8617;&#xFE0E;</span> -->
            <!-- </a> -->
        <!-- </div> -->
    

                </div>
            <div class="pagination">
                <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://dlzht.github.io/">
                            <span class="button__icon">&lt;--</span>&nbsp;
                            <span class="button__text">Perv</span>
                        </a>
                    </span>
                
                    <span class="button next">
                        <a href="https://dlzht.github.io/page/3/">
                            <span class="button__text">Next</span>&nbsp;
                            <span class="button__icon">--&gt;</span>
                        </a>
                    </span>
                </div>
            </div>
        </div>
        
    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright copyright--user">Email:&nbsp;<a href=mailto:dlzht@protonmail.com>dlzht@protonmail.com</a></div>
            </div>
    </footer>
    

</div>
</body>

</html>
